#!KAMAILIO
#
# Veil — Kamailio SIP Server Configuration
# Supports TLS (native SIP) + WSS (WebSocket) + RTPEngine media relay + push webhooks
#

####### Global Parameters #########

debug=3
log_stderror=yes
memdbg=5
memlog=5

children=4
auto_aliases=no
enable_tls=1

# Listen on UDP for dev/testing (native SIP clients without TLS)
# The advertise address is substituted by entrypoint.sh from SERVER_IP env var.
listen=udp:0.0.0.0:5060 advertise __SERVER_IP__:5060
listen=udp:[::]:5060 advertise __SERVER_IP__:5060
# Listen on TLS for native SIP clients and WSS for WebRTC/browser clients
listen=tls:0.0.0.0:5061 advertise __SERVER_IP__:5061
# WSS for WebRTC/browser clients (mapped to host port 8089)
listen=tls:0.0.0.0:8089 advertise __SERVER_IP__:8089

# TCP/TLS parameters
tcp_connection_lifetime=3604
tcp_max_connections=2048

####### Modules Section ########

loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "tls.so"
loadmodule "nathelper.so"
loadmodule "db_postgres.so"
loadmodule "websocket.so"
loadmodule "rtpengine.so"
loadmodule "http_client.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "sdpops.so"
loadmodule "xhttp.so"

####### Module Parameters ########

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "received_avp", "$avp(RECEIVED)")
modparam("registrar", "max_contacts", 5)

# ----- usrloc params -----
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", "postgres://kamailio:kamailio_default@db/ejabberd")
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", 6)

# ----- auth_db params -----
modparam("auth_db", "db_url", "postgres://kamailio:kamailio_default@db/ejabberd")
modparam("auth_db", "calculate_ha1", 0)
modparam("auth_db", "password_column", "ha1")
modparam("auth_db", "user_column", "username")
modparam("auth_db", "domain_column", "domain")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "version_table", 0)

# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("tls", "tls_force_run", 1)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:keepalive@__XMPP_DOMAIN__")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:22222")

# ----- http_client params -----
modparam("http_client", "connection_timeout", 5)
modparam("http_client", "httpcon", "apiserver=>http://api:8443")

# ----- pike params (DDoS protection) -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 4)

# ----- htable params (IP ban table) -----
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

####### Routing Logic ########

request_route {
    # Force symmetric response path (reply to source IP:port)
    force_rport();

    xlog("L_INFO", ">>> $rm from $si:$sp ($fu -> $ru) proto=$proto\n");

    # NAT handling — always apply in Docker environment
    if (is_method("REGISTER")) {
        setbflag(6);
        fix_nated_register();
        xlog("L_INFO", "NAT: fix_nated_register from $si:$sp\n");
    } else {
        fix_nated_contact();
        setbflag(6);
    }

    # DDoS protection — check if source IP is banned
    if ($sht(ipban=>$si) != $null) {
        xlog("L_WARN", "Blocked request from banned IP $si\n");
        exit;
    }

    # Pike rate limiting
    if (!pike_check_req()) {
        xlog("L_WARN", "Rate limit exceeded for $si — banning\n");
        $sht(ipban=>$si) = 1;
        exit;
    }

    # Per-request initial checks
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if (!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Handle CANCEL
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Record-Route for dialog-creating requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if (t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within existing dialogs
    if (has_totag()) {
        if (loose_route()) {
            if (is_method("BYE")) {
                # Clean up RTPEngine session on call teardown
                rtpengine_delete();
            }
            route(RELAY);
            exit;
        }

        if (is_method("ACK")) {
            if (t_check_trans()) {
                route(RELAY);
                exit;
            }
            exit;
        }

        sl_send_reply("404", "Not Found");
        exit;
    }

    # Handle REGISTER
    if (is_method("REGISTER")) {
        route(AUTH);
        if (!save("location")) {
            sl_reply_error();
        }
        exit;
    }

    # Authenticate INVITE and other requests
    if (is_method("INVITE|MESSAGE|SUBSCRIBE")) {
        route(AUTH);
    }

    # Handle INVITE — RTPEngine media relay
    if (is_method("INVITE")) {
        xlog("L_INFO", "INVITE: from=$fu to=$ru ruri=$du src=$si:$sp\n");
        route(RTPENGINE_OFFER);
        xlog("L_INFO", "INVITE: after rtpengine_offer\n");
        t_on_reply("MANAGE_REPLY");
    }

    # Lookup destination
    if (!lookup("location")) {
        if (is_method("INVITE")) {
            # Callee not registered — send VoIP push notification
            route(PUSH);
            # Reply 480 Temporarily Unavailable after push attempt
            t_reply("480", "Temporarily Unavailable");
            exit;
        }
        t_reply("404", "User Not Found");
        exit;
    }

    xlog("L_INFO", "ROUTE: relaying to $du / $ru\n");
    route(RELAY);
}

# Authentication route
route[AUTH] {
    if (!www_authorize("__XMPP_DOMAIN__", "subscriber")) {
        www_challenge("__XMPP_DOMAIN__", "1");
        exit;
    }
    consume_credentials();
}

# Relay route
route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# RTPEngine offer handling — apply correct flags based on transport
route[RTPENGINE_OFFER] {
    if ($proto == "ws" || $proto == "wss") {
        # WebSocket client: force relay with DTLS-SRTP for WebRTC
        rtpengine_manage("ICE=force-relay SDES-off DTLS=on");
    } else {
        # Native SIP client: remove ICE, use SDES-SRTP
        rtpengine_manage("ICE=remove");
    }
}

# Push notification webhook — called when callee is not registered
route[PUSH] {
    $var(caller_user) = $fU;
    $var(callee_user) = $rU;
    $var(call_id) = $ci;

    # Determine call type from SDP
    $var(call_type) = "audio";
    if (has_body("application/sdp") && sdp_with_media("video")) {
        $var(call_type) = "video";
    }

    # POST to the REST API push/call-notify endpoint (internal, no JWT)
    $var(push_body) = '{"callee_username":"' + $var(callee_user)
        + '","caller_username":"' + $var(caller_user)
        + '","caller_display_name":"' + $fn
        + '","call_id":"' + $var(call_id)
        + '","call_type":"' + $var(call_type) + '"}';

    http_client_query(
        "http://api:8443/api/v1/push/call-notify",
        $var(push_body),
        "application/json",
        $var(push_result)
    );

    xlog("L_INFO", "Push webhook result for $var(callee_user): $var(push_result)\n");
}

# Reply route — apply RTPEngine to answer SDP
onreply_route[MANAGE_REPLY] {
    if (status =~ "[12][0-9][0-9]") {
        fix_nated_contact();
        if (has_body("application/sdp")) {
            if ($proto == "ws" || $proto == "wss") {
                rtpengine_manage("ICE=force-relay SDES-off DTLS=on");
            } else {
                rtpengine_manage("ICE=remove");
            }
        }
    }
}

# Failure route
failure_route[FAIL_ROUTE] {
    if (t_is_canceled()) {
        exit;
    }
}

# WebSocket handshake handler
event_route[xhttp:request] {
    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade") {
        # Validate WebSocket origin if needed
        if (ws_handle_handshake()) {
            exit;
        }
    }

    # Reject non-WebSocket HTTP requests
    xhttp_reply("404", "Not Found", "text/plain", "Not here\n");
}
